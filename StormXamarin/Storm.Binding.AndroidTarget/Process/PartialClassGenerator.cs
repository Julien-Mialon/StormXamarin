using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Storm.Binding.AndroidTarget.Data;

namespace Storm.Binding.AndroidTarget.Process
{
	// ReSharper disable BitwiseOperatorOnEnumWithoutFlags
	class PartialClassGenerator
	{
		public void Generate(ActivityInfo activityInformations, List<string> additionalNamespaces, List<IdViewObject> views, List<XmlAttribute> bindingInformations, List<XmlResource> resourceCollection)
		{
			CodeCompileUnit codeUnit = new CodeCompileUnit();

			CodeNamespace globalNamespace = new CodeNamespace("");
			codeUnit.Namespaces.Add(globalNamespace);

			CodeNamespace codeNamespace = new CodeNamespace(activityInformations.NamespaceName);
			codeUnit.Namespaces.Add(codeNamespace);

			List<string> namespaces = new List<string>()
			{
				"System",
				"System.Collections.Generic",
				"Android.App",
				"Android.Content",
				"Android.Runtime",
				"Android.Views",
				"Android.Widget",
				"Android.OS",
				"Storm.Mvvm",
				"Storm.Mvvm.Bindings"
			};
			if (additionalNamespaces != null && additionalNamespaces.Count > 0)
			{
				namespaces.AddRange(additionalNamespaces);
			}

			foreach (string name in namespaces)
			{
				globalNamespace.Imports.Add(new CodeNamespaceImport(name));
			}

			CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration(activityInformations.ClassName)
			{
				IsClass = true,
				IsPartial = true,
				TypeAttributes = TypeAttributes.Public,
			};
			codeNamespace.Types.Add(classDeclaration);

			GenerateClassProperty(classDeclaration, views, activityInformations);

			CodeMemberMethod overrideMethod = new CodeMemberMethod
			{
				Attributes = MemberAttributes.Family | MemberAttributes.Override,
				Name = "GetBindingPaths",
				ReturnType = new CodeTypeReference("List<BindingObject>")
			};

			GenerateMethodContent(overrideMethod, classDeclaration, bindingInformations, resourceCollection, activityInformations);
			classDeclaration.Members.Add(overrideMethod);


			CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
			CodeGeneratorOptions options = new CodeGeneratorOptions
			{
				BlankLinesBetweenMembers = true,
				BracingStyle = "C",
				IndentString = "\t"
			};

			string contentString;
			using (StringWriter stringWriter = new StringWriter())
			{
				provider.GenerateCodeFromCompileUnit(codeUnit, stringWriter, options);

				string content = stringWriter.GetStringBuilder().ToString();

				Regex commentRegex = new Regex("<auto-generated>.*</auto-generated>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
				contentString = commentRegex.Replace(content, "This file was generated by binding preprocessing system for Android");
			}

			if (File.Exists(activityInformations.OutputFile))
			{
				using (StreamReader reader = new StreamReader(activityInformations.OutputFile))
				{
					string actualContent = reader.ReadToEnd();
					if (actualContent == contentString)
					{
						return;
					}
				}
				File.Delete(activityInformations.OutputFile);
			}

			using (StreamWriter writer = new StreamWriter(File.OpenWrite(activityInformations.OutputFile)))
			{
				writer.Write(contentString);
			}
		}

		/// <summary>
		/// This method generate all property to access view element with id just as Xaml do
		/// </summary>
		/// <param name="classDeclaration">The class container</param>
		/// <param name="views">The list of view elements</param>
		/// <param name="activityInformations"></param>
		private void GenerateClassProperty(CodeTypeDeclaration classDeclaration, IEnumerable<IdViewObject> views, ActivityInfo activityInformations)
		{
			foreach (IdViewObject viewItem in views)
			{
				//Console.WriteLine("Generating property for field => " + viewItem.Id + " / " + viewItem.TypeName);
				//generate a field with _id as name
				//generate a readonly property with Id as name
				// get { _id ?? (_id = findViewById(Resources.Id.<ID>))

				string fieldName = string.Format("_{0}", viewItem.Id);
				CodeMemberField field = new CodeMemberField(viewItem.TypeName, fieldName)
				{
					Attributes = MemberAttributes.Private
				};

				classDeclaration.Members.Add(field);

				CodeMemberProperty property = new CodeMemberProperty
				{
					Attributes = MemberAttributes.Family | MemberAttributes.Final, 
					Name = viewItem.Id,
					Type = new CodeTypeReference(viewItem.TypeName)
				};

				CodeMethodReferenceExpression findViewReferenceExpression;
				if (activityInformations.IsFragment)
				{
					findViewReferenceExpression = new CodeMethodReferenceExpression(
						new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "RootView"),
 						"FindViewById",
						new CodeTypeReference(viewItem.TypeName)
						);
				}
				else
				{
					findViewReferenceExpression = new CodeMethodReferenceExpression(
						new CodeThisReferenceExpression(), 
						"FindViewById", 
						new CodeTypeReference(viewItem.TypeName));
				}

				CodeMethodInvokeExpression findViewExpression = new CodeMethodInvokeExpression(
					findViewReferenceExpression,
					new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("Resource.Id"), viewItem.Id)
				);

				CodeFieldReferenceExpression fieldReference = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), fieldName);
				CodeConditionStatement ifStatement = new CodeConditionStatement(
					new CodeBinaryOperatorExpression(fieldReference, CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null)),
					new CodeAssignStatement(fieldReference, findViewExpression)
				);

				property.GetStatements.Add(ifStatement);
				property.GetStatements.Add(new CodeMethodReturnStatement(fieldReference));

				classDeclaration.Members.Add(property);
			}
		}

		private void GenerateMethodContent(CodeMemberMethod method, CodeTypeDeclaration classDeclaration, IEnumerable<XmlAttribute> bindings, IEnumerable<XmlResource> resourceCollection, ActivityInfo activityInformations)
		{
			CodeObjectCreateExpression resultCollectionInitializer = new CodeObjectCreateExpression("List<BindingObject>");
			method.Statements.Add(new CodeVariableDeclarationStatement("List<BindingObject>", "result", resultCollectionInitializer));

			CodeVariableReferenceExpression resultReference = new CodeVariableReferenceExpression("result");

			int objectCounter = 0;
			int expressionCounter = 0;

			Dictionary<string, CodeVariableReferenceExpression> resources = GenerateResourceCode(method, resourceCollection.ToList(), activityInformations);
			List<BindingExpression> expressions = bindings.Select(x => EvaluateBindingExpression(x, resources)).Where(x => x != null).ToList();

			GenerateAdapterSystem(method, classDeclaration, expressions);

			// group by binding objects
			foreach (IGrouping<string, BindingExpression> bindingExpressions in expressions.GroupBy(x => x.TargetObjectId))
			{
				//create binding objects and get a code reference on it
				CodeObjectCreateExpression objectCreateExpression = new CodeObjectCreateExpression("BindingObject", new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), bindingExpressions.Key));
				string objectName = string.Format("o{0}", objectCounter++);
				method.Statements.Add(new CodeVariableDeclarationStatement("BindingObject", objectName, objectCreateExpression));

				CodeVariableReferenceExpression objectReference = new CodeVariableReferenceExpression(objectName);

				//add the object to the result list
				method.Statements.Add(new CodeMethodInvokeExpression(resultReference, "Add", objectReference));

				//add all expressions
				foreach (BindingExpression expr in bindingExpressions)
				{
					CodeObjectCreateExpression exprCreateExpression = new CodeObjectCreateExpression("BindingExpression", new CodePrimitiveExpression(expr.TargetFieldId), new CodePrimitiveExpression(expr.SourcePath));
					string exprName = string.Format("e{0}", expressionCounter++);
					method.Statements.Add(new CodeVariableDeclarationStatement("BindingExpression", exprName, exprCreateExpression));
					CodeVariableReferenceExpression exprReference = new CodeVariableReferenceExpression(exprName);

					if (expr.ConverterReference != null)
					{
						method.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(exprReference, "Converter"), expr.ConverterReference));
					}

					if (expr.ConverterParameter != null)
					{
						method.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(exprReference, "ConverterParameter"), new CodePrimitiveExpression(expr.ConverterParameter)));
					}

					if (expr.Mode != BindingExpression.BindingModes.OneWay)
					{
						method.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(exprReference, "Mode"), new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("BindingMode"), expr.Mode.ToString())));
					}

					if (!string.IsNullOrWhiteSpace(expr.UpdateEvent))
					{
						method.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(exprReference, "UpdateEvent"), new CodePrimitiveExpression(expr.UpdateEvent)));
					}

					method.Statements.Add(new CodeMethodInvokeExpression(objectReference, "AddExpression", exprReference));
				}
			}


			method.Statements.Add(new CodeMethodReturnStatement(resultReference));
		}

		private void GenerateAdapterSystem(CodeMemberMethod method, CodeTypeDeclaration classDeclaration, IEnumerable<BindingExpression> expressions)
		{
			int adapterIndex = 0;
			const string ADAPTER_FORMAT = "AutoGenerated_Adapter{0}";
			foreach (BindingExpression expression in expressions.Where(x => x.ViewSelectorReference != null))
			{
				// Generate property for adapter
				string adapterName = string.Format(ADAPTER_FORMAT, adapterIndex++);
				CodeSnippetTypeMember propertySnippet = new CodeSnippetTypeMember(string.Format("public BindableAdapter {0} {1}", adapterName, "{get;set;}"));
				classDeclaration.Members.Add(propertySnippet);

				CodePropertyReferenceExpression propertyReference = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), adapterName);
				//Create Adapter and affect to property
				CodeObjectCreateExpression createAdapterExpression = new CodeObjectCreateExpression("BindableAdapter", expression.ViewSelectorReference);
				method.Statements.Add(new CodeAssignStatement(propertyReference, createAdapterExpression));

				//Execute MyViewObject.MyAdapterProperty = MyNewAdapter
				method.Statements.Add(new CodeAssignStatement(
					new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), expression.TargetObjectId), expression.TargetFieldId),
					propertyReference
					));

				//Change target of binding expression
				expression.TargetObjectId = adapterName;
				expression.TargetFieldId = "Collection";
			}
		}

		private Dictionary<string, CodeVariableReferenceExpression> GenerateResourceCode(CodeMemberMethod method, 
			List<XmlResource> resourceCollection, ActivityInfo activityInformations)
		{
			const string RESOURCE_NAME_FORMAT = "rsx_{0}";

			int resourceIndex = 0;
			Dictionary<string, CodeVariableReferenceExpression> res = new Dictionary<string, CodeVariableReferenceExpression>();
			foreach (ResourceConverter converter in resourceCollection.OfType<ResourceConverter>())
			{
				string resourceName = string.Format(RESOURCE_NAME_FORMAT, resourceIndex++);

				CodeObjectCreateExpression objectCreateExpression = new CodeObjectCreateExpression(converter.ClassName);
				method.Statements.Add(new CodeVariableDeclarationStatement(converter.ClassName, resourceName, objectCreateExpression));

				CodeVariableReferenceExpression resourceReference = new CodeVariableReferenceExpression(resourceName);
				res.Add(converter.Key, resourceReference);
			}

			foreach (ResourceDataTemplate dataTemplate in resourceCollection.OfType<ResourceDataTemplate>())
			{
				string resourceName = string.Format(RESOURCE_NAME_FORMAT, resourceIndex++);

				CodeFieldReferenceExpression rIdReference = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("Resource.Layout"), dataTemplate.ResourceId);
				method.Statements.Add(new CodeVariableDeclarationStatement(typeof(int), resourceName, rIdReference));

				CodeVariableReferenceExpression resourceReference = new CodeVariableReferenceExpression(resourceName);
				res.Add(dataTemplate.Key, resourceReference);
			}

			CodePropertyReferenceExpression layoutInflaterReference;
			if (activityInformations.IsFragment)
			{
				layoutInflaterReference = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Activity"), "LayoutInflater");
			}
			else
			{
				layoutInflaterReference = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "LayoutInflater");
			}

			foreach (ResourceViewSelector viewSelector in resourceCollection.OfType<ResourceViewSelector>())
			{
				string resourceName = string.Format(RESOURCE_NAME_FORMAT, resourceIndex++);

				//Create view selector item
				CodeObjectCreateExpression objectCreateExpression = new CodeObjectCreateExpression(viewSelector.ClassName, layoutInflaterReference);
				method.Statements.Add(new CodeVariableDeclarationStatement(viewSelector.ClassName, resourceName, objectCreateExpression));

				//Get reference on new object
				CodeVariableReferenceExpression resourceReference = new CodeVariableReferenceExpression(resourceName);
				res.Add(viewSelector.Key, resourceReference);

				//Affect property to view selector
				foreach (KeyValuePair<string, string> property in viewSelector.Properties)
				{
					// First, extract value of the property
					// Could be {Resource ...} or a simple string

					CodeExpression propertyValueExpression;
					if (IsResourceReferenceExpression(property.Value))
					{
						string resourceKey = ExtractResourceKey(property.Value);

						if (res.ContainsKey(resourceKey))
						{
							propertyValueExpression = res[resourceKey];
						}
						else
						{
							BindingPreprocess.Logger.LogError("Error, Resource with key = {0} does not exists", resourceKey);
							continue;
						}
					}
					else
					{
						propertyValueExpression = new CodePrimitiveExpression(property.Value);
					}

					method.Statements.Add(new CodeAssignStatement(
						new CodePropertyReferenceExpression(resourceReference, property.Key),
						propertyValueExpression
						));
				}
				
			}

			return res;
		}

		private bool IsResourceReferenceExpression(string input)
		{
			const string RESOURCE_ACCESS_START = "{Resource ";
			const string RESOURCE_ACCESS_END = "}";

			input = input.Trim();
			return (input.StartsWith(RESOURCE_ACCESS_START) && input.EndsWith(RESOURCE_ACCESS_END));
		}

		private string ExtractResourceKey(string input)
		{
			const string RESOURCE_ACCESS_START = "{Resource ";
			const string RESOURCE_ACCESS_END = "}";

			input = input.Trim();
			if (input.StartsWith(RESOURCE_ACCESS_START) && input.EndsWith(RESOURCE_ACCESS_END))
			{
				input = input.Substring(RESOURCE_ACCESS_START.Length);
				input = input.Substring(0, input.Length - RESOURCE_ACCESS_END.Length).Trim();

				return input;
			}
			return null;
		}

		private BindingExpression EvaluateBindingExpression(XmlAttribute attribute, Dictionary<string, CodeVariableReferenceExpression> resources)
		{
			const string BINDING_EXPRESSION_START = "{Binding ";
			const string BINDING_EXPRESSION_END = "}";

			string bindingValue = attribute.Value;
			if (bindingValue.StartsWith(BINDING_EXPRESSION_START) && bindingValue.EndsWith(BINDING_EXPRESSION_END))
			{
				bindingValue = bindingValue.Substring(BINDING_EXPRESSION_START.Length);
				bindingValue = bindingValue.Substring(0, bindingValue.Length - BINDING_EXPRESSION_END.Length).Trim();

				//Format des bindings expression
				/*{Binding [Path=]Path[, Converter={Resource ConverterKey}[, ConverterParameter=(VALUE|'SPACED VALUE')]][, Mode=(OneTime|OneWay|TwoWay)[, UpdateEvent=EventName]]
				 * Le nom de l'attribut Path est optionel
				 * ConverterParameter n'est autorisé que si il y a un converter
				 * UpdateEvent n'est autorisé qu'avec un mode "TwoWay"
				 */
				BindingExpression expression = new BindingExpression
				{
					TargetFieldId = attribute.LocalName,
					TargetObjectId = attribute.AttachedId
				};
				bool pathFound = false;
				Regex pattern = new Regex("^([a-zA-Z0-9]+) ?= ?(.+)$");
				foreach (string attr in bindingValue.Split(',').Where(x => !string.IsNullOrWhiteSpace(x)).Select(x => x.Trim()))
				{
					string attributeName;
					string attributeValue;

					if (pattern.IsMatch(attr))
					{
						Match matchResult = pattern.Match(attr);
						attributeName = matchResult.Groups[1].Value;
						attributeValue = matchResult.Groups[2].Value;
					}
					else //on suppose que c'est le path
					{
						attributeName = "Path";
						attributeValue = attr;
					}

					if (attributeName == "Path")
					{
						if (pathFound)
						{
							BindingPreprocess.Logger.LogError("Binding error : missing attribute name in " + bindingValue);
							return null;
						}
						pathFound = true;

						expression.SourcePath = attributeValue;
					}
					else if (attributeName == "Converter")
					{
						// need to parse {Resource ... }
						if (IsResourceReferenceExpression(attributeValue))
						{
							string resourceKey = ExtractResourceKey(attributeValue);

							if (resources.ContainsKey(resourceKey))
							{
								expression.ConverterReference = resources[resourceKey];
							}
							else
							{
								BindingPreprocess.Logger.LogError("Binding error : no converter in ressource for " + bindingValue);
							}
						}
						else
						{
							BindingPreprocess.Logger.LogError("Binding Error : invalid converter " + bindingValue);
							return null;
						}
					}
					else if (attributeName == "ConverterParameter")
					{
						if (attributeValue.StartsWith("'") && attributeValue.EndsWith("'"))
						{
							attributeValue = attributeValue.Substring(1, attributeValue.Length - 2).Replace("\\\\", "\\").Replace("\\'", "'");
						}
						expression.ConverterParameter = attributeValue;
					}
					else if (attributeName == "Mode")
					{
						BindingExpression.BindingModes enumResult;
						if (Enum.TryParse(attributeValue, false, out enumResult))
						{
							expression.Mode = enumResult;
						}
						else
						{
							BindingPreprocess.Logger.LogError("Binding error : unrecognized Binding Mode " + attributeValue);
							return null;
						}
					}
					else if (attributeName == "UpdateEvent")
					{
						expression.UpdateEvent = attributeValue;
					}
					else if (attributeName == "ViewSelector")
					{
						// need to parse {Resource ... }
						if (IsResourceReferenceExpression(attributeValue))
						{
							string resourceKey = ExtractResourceKey(attributeValue);

							if (resources.ContainsKey(resourceKey))
							{
								expression.ViewSelectorReference = resources[resourceKey];
							}
							else
							{
								BindingPreprocess.Logger.LogError("Binding error : no viewselector in ressource for " + bindingValue);
							}
						}
						else
						{
							BindingPreprocess.Logger.LogError("Binding Error : invalid viewselector " + bindingValue);
							return null;
						}
					}
					else
					{
						BindingPreprocess.Logger.LogError("Unrecognized attribute {0} in binding expression {1}", attributeName, bindingValue);
					}
				}

				if (!pathFound)
				{
					expression.SourcePath = "";
				}

				if (expression.ConverterReference == null && !string.IsNullOrWhiteSpace(expression.ConverterParameter))
				{
					BindingPreprocess.Logger.LogError("Binding Error : ConverterParameter is not authorized if no converter is specified " + bindingValue);
					//Console.WriteLine("Binding Error : ConverterParameter is not authorized if no converter is specified " + bindingValue);
					return null;
				}

				if (expression.Mode != BindingExpression.BindingModes.TwoWay && !string.IsNullOrWhiteSpace(expression.UpdateEvent))
				{
					BindingPreprocess.Logger.LogError("Binding Error : UpdateEvent is not authorized if Mode is not TwoWay " + bindingValue);
					//Console.WriteLine("Binding Error : UpdateEvent is not authorized if Mode is not TwoWay " + bindingValue);
					return null;
				}

				if (expression.Mode == BindingExpression.BindingModes.TwoWay && string.IsNullOrWhiteSpace(expression.UpdateEvent))
				{
					BindingPreprocess.Logger.LogError("Binding error : missing update event for two way binding : " + bindingValue);
					//Console.WriteLine("Binding error : missing update event for two way binding : " + bindingValue);
					return null;
				}

				return expression;
			}
			Console.WriteLine("Binding error : " + bindingValue);
			return null;
		}

		class BindingExpression
		{
			public enum BindingModes
			{
				OneWay,
				TwoWay
			}

			/* Mandatory fields */
			public string TargetObjectId { get; set; }

			public string TargetFieldId { get; set; }

			public string SourcePath { get; set; }

			/* Optional fields */
			public CodeVariableReferenceExpression ConverterReference { get; set; }

			// only if converter specified
			public string ConverterParameter { get; set; }

			public CodeVariableReferenceExpression ViewSelectorReference { get; set; }

			// default value : OneWay
			public BindingModes Mode { get; set; }

			// only if Mode = TwoWay
			public string UpdateEvent { get; set; }

			public BindingExpression()
			{
				Mode = BindingModes.OneWay;
			}
		}
	}

	// ReSharper restore BitwiseOperatorOnEnumWithoutFlags
}
