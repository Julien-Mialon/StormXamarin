using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

namespace Storm.Binding.AndroidTarget.Process
{
	// ReSharper disable BitwiseOperatorOnEnumWithoutFlags
	public class ViewHolderFactoryGenerator
	{
		public const string FACTORY_CLASS_NAME = "AutoGenerated_ViewHolderFactory";
		public const string FIELD_NAME = "GeneratedDictionary";
		public const string GET_METHOD_NAME = "Get";

		private const string METHOD_FORMAT = "AutoGenerated_CreateMethod_{0}";

		private readonly string _namespaceName;

		private static readonly CodeTypeReferenceExpression _staticReference = new CodeTypeReferenceExpression(FACTORY_CLASS_NAME);
		public static readonly CodeMethodReferenceExpression GetMethodReference = new CodeMethodReferenceExpression(_staticReference, GET_METHOD_NAME);

		private static readonly CodeTypeReference _viewHolderType = new CodeTypeReference("BaseViewHolder");
		private static readonly CodeTypeReference _funcType = new CodeTypeReference("Func", new CodeTypeReference("LayoutInflater"), new CodeTypeReference("View"), _viewHolderType);
		private static readonly CodeTypeReference _fieldType = new CodeTypeReference("Dictionary", new CodeTypeReference(typeof(int)), _funcType);

		public List<Tuple<ResourceDataTemplate, string, string>> Templates { get; set; }
		public List<string> Namespaces { get; set; }

		public ViewHolderFactoryGenerator(string namespaceName)
		{
			_namespaceName = namespaceName;
		}

		public void Generate(string outputFile)
		{
			CodeCompileUnit codeUnit = new CodeCompileUnit();

			CodeNamespace globalNamespace = new CodeNamespace("");
			codeUnit.Namespaces.Add(globalNamespace);

			CodeNamespace codeNamespace = new CodeNamespace(_namespaceName);
			codeUnit.Namespaces.Add(codeNamespace);

			List<string> usings = ClassGeneratorHelper.DefaultNamespaces;
			if (Namespaces != null && Namespaces.Any())
			{
				usings.AddRange(Namespaces);
			}

			foreach (string name in usings)
			{
				globalNamespace.Imports.Add(new CodeNamespaceImport(name));
			}

			CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration(FACTORY_CLASS_NAME)
			{
				IsClass = true,
				TypeAttributes = TypeAttributes.Public,
			};

			CodeFieldReferenceExpression field = GenerateField(classDeclaration);
			GenerateConstructor(classDeclaration, field);
			GenerateAccessMethod(classDeclaration, field);

			codeNamespace.Types.Add(classDeclaration);

			
			#region File writing

			CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
			CodeGeneratorOptions options = new CodeGeneratorOptions
			{
				BlankLinesBetweenMembers = true,
				BracingStyle = "C",
				IndentString = "\t"
			};

			string contentString;
			using (StringWriter stringWriter = new StringWriter())
			{
				provider.GenerateCodeFromCompileUnit(codeUnit, stringWriter, options);

				string content = stringWriter.GetStringBuilder().ToString();

				Regex commentRegex = new Regex("<auto-generated>.*</auto-generated>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
				contentString = commentRegex.Replace(content, "This file was generated by binding preprocessing system for Android");
			}

			if (File.Exists(outputFile))
			{
				using (StreamReader reader = new StreamReader(outputFile))
				{
					string actualContent = reader.ReadToEnd();
					if (actualContent == contentString)
					{
						return;
					}
				}
				File.Delete(outputFile);
			}

			using (StreamWriter writer = new StreamWriter(File.OpenWrite(outputFile)))
			{
				writer.Write(contentString);
			}

			#endregion
		}

		private void GenerateAccessMethod(CodeTypeDeclaration classDeclaration, CodeFieldReferenceExpression fieldReference)
		{
			CodeMemberMethod method = new CodeMemberMethod
			{
				Attributes = MemberAttributes.Static | MemberAttributes.Public,
				Name = GET_METHOD_NAME
			};

			classDeclaration.Members.Add(method);

			method.ReturnType = _viewHolderType;
			method.Parameters.Add(new CodeParameterDeclarationExpression("LayoutInflater", "layoutInflater"));
			method.Parameters.Add(new CodeParameterDeclarationExpression("View", "view"));
			method.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(typeof (int)), "id"));

			string snippet = string.Format("\t\t\t\treturn {0}[{1}]({2}, {3});", fieldReference.FieldName, "id", "layoutInflater", "view");

			CodeConditionStatement ifKeyStatement = new CodeConditionStatement(
				new CodeMethodInvokeExpression(fieldReference, "ContainsKey", new CodeVariableReferenceExpression("id")),
					new CodeSnippetStatement(snippet)					
				);
			method.Statements.Add(ifKeyStatement);
			method.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
		}

		private void GenerateConstructor(CodeTypeDeclaration classDeclaration, CodeFieldReferenceExpression fieldReference)
		{
			CodeTypeConstructor constructor = new CodeTypeConstructor
			{
				Attributes = MemberAttributes.Static | MemberAttributes.Final | MemberAttributes.Private
			};

			classDeclaration.Members.Add(constructor);

			int methodIndex = 0;
			foreach (Tuple<ResourceDataTemplate, string, string> item in Templates)
			{
				string namespaceName = item.Item2;
				string className = item.Item3;
				string dataTemplateKey = item.Item1.ResourceId;

				CodeFieldReferenceExpression resourceReference = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("Resource.Layout"), dataTemplateKey);

				CodeMethodInvokeExpression addMethod = new CodeMethodInvokeExpression(
					fieldReference, "Add",
					resourceReference,
					GenerateMethod(classDeclaration, methodIndex++, namespaceName, className)
					);
				constructor.Statements.Add(addMethod);
			}
		}

		private CodeMethodReferenceExpression GenerateMethod(CodeTypeDeclaration classDeclaration, int index, string namespaceName, string className)
		{
			string methodName = string.Format(METHOD_FORMAT, index);

			CodeMemberMethod method = new CodeMemberMethod
			{
				Attributes = MemberAttributes.Static | MemberAttributes.Private,
				Name = methodName
			};

			classDeclaration.Members.Add(method);

			method.ReturnType = _viewHolderType;
			method.Parameters.Add(new CodeParameterDeclarationExpression("LayoutInflater", "layoutInflater"));
			method.Parameters.Add(new CodeParameterDeclarationExpression("View", "view"));
			method.Statements.Add(new CodeMethodReturnStatement(new CodeObjectCreateExpression(string.Format("{0}.{1}", namespaceName, className), new CodeVariableReferenceExpression("layoutInflater"), new CodeVariableReferenceExpression("view"))));

			return new CodeMethodReferenceExpression(_staticReference, methodName);
		}

		private CodeFieldReferenceExpression GenerateField(CodeTypeDeclaration classDeclaration)
		{
			
			CodeMemberField field = new CodeMemberField(_fieldType, FIELD_NAME)
			{
				Attributes = MemberAttributes.Private | MemberAttributes.Static, 
				InitExpression = new CodeObjectCreateExpression(_fieldType)
			};

			classDeclaration.Members.Add(field);
			return new CodeFieldReferenceExpression(_staticReference, FIELD_NAME);
		}
	}
	// ReSharper restore BitwiseOperatorOnEnumWithoutFlags
}
